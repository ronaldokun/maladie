<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Blood Markers Evolution Analysis</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
<style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 10px;
        }
        .chart-container {
            margin: 30px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .dropdown-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            min-width: 250px;
        }
        .download-buttons {
            display: flex;
            gap: 10px;
        }
        .download-btn {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        .download-btn:hover {
            background: #005999;
        }
        .altered {
            color: red;
            font-weight: bold;
        }
        .focus-box {
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, #fff3cd 0%, #f8d7da 100%);
            border: 2px solid #dc3545;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.2);
            display: none;
        }
        .focus-box.visible {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .focus-box h3 {
            margin: 0 0 15px 0;
            color: #721c24;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .focus-box h3:before {
            content: "⚠️";
            font-size: 20px;
        }
        .focus-box-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .focus-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
        }
        .focus-item-name {
            font-weight: bold;
            color: #721c24;
            margin-bottom: 5px;
        }
        .focus-item-value {
            font-size: 16px;
            color: #dc3545;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .direction-arrow {
            font-size: 18px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 24px;
            text-align: center;
        }
        .arrow-up {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            border: 1px solid rgba(220, 53, 69, 0.3);
        }
        .arrow-down {
            color: #fd7e14;
            background: rgba(253, 126, 20, 0.1);
            border: 1px solid rgba(253, 126, 20, 0.3);
        }
        .focus-item-reference {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .focus-box-empty {
            text-align: center;
            color: #28a745;
            font-weight: bold;
            background: rgba(40, 167, 69, 0.1);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #28a745;
        }
    </style>
</head>
<body>
<div class="container">
<h1>Blood Markers Evolution Analysis</h1>
<p><strong>Patient:</strong> [ANONYMIZED] (ID: [REDACTED])</p>
<p id="periodText"><strong>Period:</strong> Loading...</p>
<div class="controls">
<div class="dropdown-container">
<label for="groupSelect"><strong>Select Group:</strong></label>
<select id="groupSelect" onchange="updateAnalytesForGroup()"></select>
</div>

<div class="dropdown-container">
<label for="analyteSelect"><strong>Select Analyte:</strong></label>
<select id="analyteSelect" onchange="updateChart()">
</select>
</div>
<div class="download-buttons">
<button class="download-btn" onclick="downloadPivotCSV()">Download Pivot Table CSV</button>
<button class="download-btn" onclick="downloadTidyCSV()">Download Tidy Data CSV</button>
</div>
</div>
<div class="chart-container">
<h2>Interactive Evolution Chart</h2>
<div class="info-box" style="margin-bottom: 10px; padding: 8px; background-color: #f8f9fa; border-radius: 5px; font-size: 14px;">
  <p style="margin: 0;"><strong>Navigation tips:</strong> Use the range slider below the chart to zoom and pan. You can also use the toolbar buttons to zoom in/out and drag to pan the view.</p>
</div>
<div id="plotlyChart" style="height: 700px;"></div>
<div id="fileLoader" style="display:none; margin-top: 12px; padding: 10px; background:#fff3cd; border:1px solid #ffeeba; border-radius:6px;">
  <p style="margin:0 0 8px 0;">Could not load blood_markers_pivot.csv automatically. If you opened this file directly from your disk (file://), please choose the CSV located in the same folder as this HTML:</p>
  <input type="file" id="csvInput" accept=".csv" />
</div>
<div id="focusBox" class="focus-box">
  <h3>Latest Results - Attention Required</h3>
  <div id="focusBoxContent" class="focus-box-content">
    <!-- Content will be dynamically generated -->
  </div>
</div>
</div>
</div>
<script>
        // Global variables for data - will be populated from CSV
        let rawData = [];
        let dateTimes = [];
        let isDataLoaded = false;

        // Function to load and parse CSV data
        async function loadCSVData() {
            try {
                // Always expect CSV in the same folder as index.html
                const csvUrl = new URL('blood_markers_pivot.csv', window.location.href).href;
                const response = await fetch(csvUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const csvText = await response.text();
                parseCSVText(csvText);
                isDataLoaded = true;
                updatePeriodDisplay();
                console.log(`Loaded ${rawData.length} analytes with ${dateTimes.length} time points`);
            } catch (error) {
                console.warn('Automatic CSV load failed (likely due to file:// restrictions). Enabling manual file picker...', error);
                // Show file picker fallback for local file access
                enableManualCSVPicker();
                isDataLoaded = false;
            }
        }

        // Parse CSV text into rawData/dateTimes
        function parseCSVText(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('Invalid CSV format');
            }
            // Parse header row to get dates
            const headers = parseCSVLine(lines[0]);
            dateTimes = headers.slice(1, -1); // Remove first (ANALITOS) and last (VALORES DE REFERENCIA) columns
            // Parse data rows
            rawData = [];
            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (row.length < 3) continue; // Skip incomplete rows
                const analyteName = row[0];
                const values = row.slice(1, -1); // Remove first and last columns
                const referenceWithUnit = row[row.length - 1] || '';
                // Parse unit and reference from the last column
                const unitMatch = referenceWithUnit.match(/([^\s]+)$/);
                const unit = unitMatch ? unitMatch[1] : '';
                const reference = referenceWithUnit.replace(new RegExp('\\s*' + unit.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$'), '').trim();
                // Convert numeric values, keep strings as-is
                const processedValues = values.map(val => {
                    if (val === '----' || val === 'Inferior a 0.5' || val === 'Raras' || val === '---') {
                        return val;
                    }
                    const num = parseFloat(val);
                    return isNaN(num) ? val : num;
                });
                rawData.push({ analyte: analyteName, values: processedValues, unit: unit, reference: reference });
            }
        }

        // Show manual CSV picker and wire up parsing
        function enableManualCSVPicker() {
            const picker = document.getElementById('fileLoader');
            const input = document.getElementById('csvInput');
            if (!picker || !input) return;
            picker.style.display = 'block';
            input.addEventListener('change', function(ev) {
                const file = ev.target.files && ev.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseCSVText(e.target.result);
                        isDataLoaded = true;
                        picker.style.display = 'none';
                        populateGroups();
                        updateChart();
                        updatePeriodDisplay();
                    } catch (err) {
                        alert('Failed to parse CSV: ' + err.message);
                    }
                };
                reader.readAsText(file, 'utf-8');
            }, { once: true });
        }
        
        // Function to parse CSV line handling quoted values
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }
        
        // Function to update period display based on loaded data
        function updatePeriodDisplay() {
            if (!isDataLoaded || dateTimes.length === 0) return;
            
            // Find earliest and latest dates
            const dates = dateTimes.map(dateStr => {
                // Convert from DD/MM/YYYY format to Date object
                const parts = dateStr.split(/[\s/]/);
                if (parts.length >= 3) {
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1; // Month is 0-indexed
                    const year = parseInt(parts[2]);
                    return new Date(year, month, day);
                }
                return new Date(dateStr);
            }).filter(date => !isNaN(date.getTime()));
            
            if (dates.length === 0) return;
            
            dates.sort((a, b) => a - b);
            const earliestDate = dates[0];
            const latestDate = dates[dates.length - 1];
            
            const diffTime = Math.abs(latestDate - earliestDate);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            const formatDate = (date) => {
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const year = date.getFullYear();
                return `${day}/${month}/${year}`;
            };
            
            // Update the period display in the DOM
            const periodElement = document.getElementById('periodText');
            if (periodElement) {
                periodElement.innerHTML = `<strong>Period:</strong> ${formatDate(earliestDate)} to ${formatDate(latestDate)} (${diffDays} days)`;
            }
        }

        // Function to parse reference ranges
        function parseReference(refString) {
            if (!refString || refString === "") return {min: null, max: null};
            
            const patterns = [
                /De\s+([\d.-]+)\s+até\s+([\d.]+)/i,
                /De\s+([\d.-]+)\s+a\s+([\d.]+)/i,
                /Até\s+([\d.]+)/i,
                /até\s+([\d.]+)/i
            ];
            
            for (let pattern of patterns) {
                const match = refString.match(pattern);
                if (match) {
                    if (match[2]) {
                        return {min: parseFloat(match[1]), max: parseFloat(match[2])};
                    } else {
                        return {min: null, max: parseFloat(match[1])};
                    }
                }
            }
            
            return {min: null, max: null};
        }

        // Function to calculate median of valid numeric values
        function calculateMedian(values) {
            // Filter out invalid values and convert to numbers
            const numericValues = values.filter(val => {
                if (val === "----" || val === null || val === "Inferior a 0.5" || val === "Raras") return false;
                const num = parseFloat(val);
                return !isNaN(num);
            }).map(val => {
                if (val === "Inferior a 0.5") return 0.25;
                if (val === "Raras") return 0;
                return parseFloat(val);
            });
            
            if (numericValues.length === 0) return null;
            
            // Sort values
            numericValues.sort((a, b) => a - b);
            
            const mid = Math.floor(numericValues.length / 2);
            
            if (numericValues.length % 2 === 0) {
                return (numericValues[mid - 1] + numericValues[mid]) / 2;
            } else {
                return numericValues[mid];
            }
        }

        // Function to check if value is within reference range
        function isWithinRange(value, reference) {
            if (value === "----" || value === null || value === "Inferior a 0.5" || value === "Raras") return null;
            const ref = parseReference(reference);
            if (ref.min === null && ref.max === null) return null;
            
            const numValue = parseFloat(value);
            if (isNaN(numValue)) return null;
            
            if (ref.min !== null && ref.max !== null) {
                return numValue >= ref.min && numValue <= ref.max;
            } else if (ref.max !== null) {
                return numValue <= ref.max;
            }
            return null;
        }

        // Function to determine direction of out-of-range value
        function getOutOfRangeDirection(value, reference) {
            const ref = parseReference(reference);
            const numValue = parseFloat(value);
            
            if (isNaN(numValue) || (ref.min === null && ref.max === null)) {
                return null;
            }
            
            if (ref.min !== null && ref.max !== null) {
                // Both min and max defined
                if (numValue < ref.min) return 'down';
                if (numValue > ref.max) return 'up';
                return null;
            } else if (ref.max !== null) {
                // Only max defined
                if (numValue > ref.max) return 'up';
                return null;
            }
            
            return null;
        }

        // Function to get out-of-range values for the latest data point
        function getLatestOutOfRangeValues() {
            const outOfRange = [];
            
            rawData.forEach(analyte => {
                const latestValue = analyte.values[0]; // First value is the latest
                const withinRange = isWithinRange(latestValue, analyte.reference);
                
                if (withinRange === false && analyte.reference && analyte.reference.trim() !== "") {
                    // Handle special values for display
                    let displayValue = latestValue;
                    if (latestValue === "Inferior a 0.5") displayValue = "<0.5";
                    
                    // Determine direction
                    const direction = getOutOfRangeDirection(latestValue, analyte.reference);
                    
                    outOfRange.push({
                        name: analyte.analyte,
                        value: displayValue,
                        unit: analyte.unit,
                        reference: analyte.reference,
                        rawValue: latestValue,
                        direction: direction
                    });
                }
            });
            
            return outOfRange;
        }

        // Function to update the focus box
        function updateFocusBox() {
            const outOfRange = getLatestOutOfRangeValues();
            const focusBox = document.getElementById('focusBox');
            const focusBoxContent = document.getElementById('focusBoxContent');
            
            if (outOfRange.length === 0) {
                focusBoxContent.innerHTML = '<div class="focus-box-empty">✅ All latest measurements are within reference ranges</div>';
                focusBox.className = 'focus-box visible';
                focusBox.style.background = 'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)';
                focusBox.style.borderColor = '#28a745';
            } else {
                let contentHtml = '';
                outOfRange.forEach(item => {
                    // Create arrow indicator based on direction
                    let arrowHtml = '';
                    if (item.direction === 'up') {
                        arrowHtml = '<span class="direction-arrow arrow-up">↑</span>';
                    } else if (item.direction === 'down') {
                        arrowHtml = '<span class="direction-arrow arrow-down">↓</span>';
                    }
                    
                    contentHtml += `
                        <div class="focus-item">
                            <div class="focus-item-name">${item.name}</div>
                            <div class="focus-item-value">${arrowHtml}${item.value} ${item.unit}</div>
                            <div class="focus-item-reference">Reference: ${item.reference} ${item.unit}</div>
                        </div>
                    `;
                });
                focusBoxContent.innerHTML = contentHtml;
                focusBox.className = 'focus-box visible';
                focusBox.style.background = 'linear-gradient(135deg, #fff3cd 0%, #f8d7da 100%)';
                focusBox.style.borderColor = '#dc3545';
                
                // Update the title to show count
                const titleElement = focusBox.querySelector('h3');
                titleElement.textContent = `Latest Results - ${outOfRange.length} Measurement${outOfRange.length > 1 ? 's' : ''} Outside Reference Range`;
            }
        }

        // Create dropdown options
        function createDropdown() {
            const select = document.getElementById('analyteSelect');
            rawData.forEach(row => {
                const option = document.createElement('option');
                option.value = row.analyte;
                option.textContent = row.analyte;
                select.appendChild(option);
            });
            // Select first analyte by default
            if (rawData.length > 0) {
                select.value = rawData[0].analyte;
            }
        }

        // Create plotly chart for selected analyte
        function updateChart() {
            const selectedAnalyte = document.getElementById('analyteSelect').value;
            const analyte = rawData.find(a => a.analyte === selectedAnalyte);
            if (!analyte) return;
            
            // Reverse the order for chronological display (left to right)
            const reversedDates = [...dateTimes].reverse();
            const reversedValues = [...analyte.values].reverse();
            
            // Filter out invalid values and get corresponding dates
            const validData = reversedValues.map((value, idx) => ({
                value: value,
                date: reversedDates[idx],
                originalValue: value
            })).filter(item => item.value !== "----");
            
            if (validData.length === 0) return;
            
            const validDates = validData.map(item => item.date);
            const validValues = validData.map(item => {
                // Handle special values
                if (item.value === "Inferior a 0.5") return 0.25;
                if (item.value === "Raras") return 0;
                return parseFloat(item.value);
            });
            
            // Create trace
            const trace = {
                x: validDates,
                y: validValues,
                name: analyte.analyte,
                mode: 'lines+markers+text',
                connectgaps: true,
                text: validData.map(item => {
                    if (item.originalValue === "Inferior a 0.5") return "<0.5";
                    if (item.originalValue === "Raras") return "Raras";
                    return `${item.originalValue}`;
                }),
                textposition: 'top center',
                textfont: {size: 12},
                hovertemplate: `<b>${analyte.analyte}</b><br>` +
                               `DateTime: %{x}<br>` +
                               `Value: %{text} ${analyte.unit}<br>` +
                               `Reference: ${analyte.reference} ${analyte.unit}<br>` +
                               `<extra></extra>`,
                line: {width: 3, color: '#007acc'},
                marker: {size: 8, color: '#007acc'},
                textangle: 0
            };
            
            // Calculate median for trend analysis
            const medianValue = calculateMedian(analyte.values);
            
            const traces = [trace];
            const shapes = [];
            
            // Add median line if available
            if (medianValue !== null) {
                shapes.push({
                    type: 'line',
                    x0: 0,
                    x1: 1,
                    xref: 'paper',
                    y0: medianValue,
                    y1: medianValue,
                    line: {
                        color: 'rgba(255, 165, 0, 0.8)', // Orange color
                        width: 2,
                        dash: 'dot'
                    },
                    layer: 'above'
                });
                
                // Add median trace for legend
                traces.push({
                    x: [null],
                    y: [null],
                    mode: 'lines',
                    name: `Median Trend (${medianValue.toFixed(2)} ${analyte.unit})`,
                    line: {
                        color: 'rgba(255, 165, 0, 0.8)',
                        width: 2,
                        dash: 'dot'
                    },
                    showlegend: true
                });
            }
            
            // Add reference range as filled area if available
            const ref = parseReference(analyte.reference);
            if (ref.min !== null || ref.max !== null) {
                // Create filled reference range area
                if (ref.min !== null && ref.max !== null) {
                    // Both min and max defined - create filled rectangle
                    shapes.push({
                        type: 'rect',
                        x0: 0,
                        x1: 1,
                        xref: 'paper',
                        y0: ref.min,
                        y1: ref.max,
                        fillcolor: 'rgba(144, 238, 144, 0.3)', // Light green with transparency
                        line: {
                            width: 0
                        },
                        layer: 'below'
                    });
                } else if (ref.max !== null) {
                    // Only max defined - create filled area from bottom to max
                    const yAxisMin = Math.min(...validValues) * 0.8; // Estimate bottom of plot
                    shapes.push({
                        type: 'rect',
                        x0: 0,
                        x1: 1,
                        xref: 'paper',
                        y0: yAxisMin,
                        y1: ref.max,
                        fillcolor: 'rgba(144, 238, 144, 0.3)', // Light green with transparency
                        line: {
                            width: 0
                        },
                        layer: 'below'
                    });
                }
                
                // Add invisible trace for reference range legend
                traces.push({
                    x: [null],
                    y: [null],
                    mode: 'markers',
                    marker: {
                        size: 10,
                        color: 'rgba(144, 238, 144, 0.8)',
                        symbol: 'square'
                    },
                    name: 'Reference Range',
                    showlegend: true
                });
            }
            
            const layout = {
                title: {
                    text: `${analyte.analyte} Evolution Over Time`,
                    font: {size: 18}
                },
                xaxis: {
                    title: 'Date/Time',
                    tickangle: -45,
                    type: 'category',
                    rangeslider: { visible: true },
                    automargin: true,
                    rangemode: 'normal'
                },
                yaxis: {
                    title: `Value (${analyte.unit})`,
                    automargin: true
                },
                hovermode: 'closest',
                showlegend: true,
                shapes: shapes,
                margin: {r: 50, b: 120, t: 80, l: 80}
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                scrollZoom: true,
                modeBarButtonsToAdd: ['scrollZoom', 'pan2d', 'zoomIn2d', 'zoomOut2d', 'resetScale2d'],
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };
            
            Plotly.newPlot('plotlyChart', traces, layout, config);
            
            // Update the focus box with latest out-of-range values
            updateFocusBox();
        }

        // Download functions
        function downloadPivotCSV() {
            let csv = 'ANALITOS,';
            csv += dateTimes.join(',') + ',VALORES DE REFERENCIA\n';
            
            rawData.forEach(row => {
                csv += row.analyte + ',';
                csv += row.values.join(',') + ',';
                csv += '"' + row.reference + ' ' + row.unit + '"\n';
            });
            
            downloadCSV(csv, 'blood_markers_pivot.csv');
        }

        function downloadTidyCSV() {
            let csv = 'Analyte,DateTime,Value,Unit,Reference Range,Within Range\n';
            
            rawData.forEach(row => {
                row.values.forEach((value, index) => {
                    if (value !== "----") {
                        const withinRange = isWithinRange(value, row.reference);
                        const withinRangeText = withinRange === null ? 'N/A' : (withinRange ? 'Yes' : 'No');
                        csv += `"${row.analyte}","${dateTimes[index]}","${value}","${row.unit}","${row.reference}","${withinRangeText}"\n`;
                    }
                });
            });
            
            downloadCSV(csv, 'blood_markers_tidy.csv');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', async function() {
            // Show loading message
            const chartContainer = document.getElementById('plotlyChart');
            chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 400px; font-size: 18px; color: #666;">Loading data...</div>';
            
            // Load CSV data first
            await loadCSVData();
            
            if (isDataLoaded) {
                populateGroups();
                updateChart();
            } else {
                chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 400px; font-size: 18px; color: #d32f2f;">Error: Could not load data from CSV file</div>';
            }
        });
    
        const groups = {"Inflammatory": ["Proteína C reativa"], "Hematology": ["Hemoglobina", "Hemácias", "Hematócrito", "RDW", "Leucócitos", "Plaquetas", "Linfócitos", "Neutrófilos", "Monócitos", "Eosinófilos", "Basófilos", "Bastões"], "Kidney": ["Creatinina", "Ureia"], "Liver": ["TGO", "TGP", "Gama GT", "Fosfatase alcalina"], "Electrolytes / Minerals": ["Sódio", "Potássio", "Calcio Iônico", "Magnesio"], "Coagulation": ["RNI", "TAP", "TTPA", "Relação"]};

        // Populate group dropdown
        function populateGroups() {
            const groupSelect = document.getElementById("groupSelect");
            Object.keys(groups).forEach(g => {
                let option = document.createElement("option");
                option.value = g;
                option.text = g;
                groupSelect.add(option);
            });
            updateAnalytesForGroup();
        }

        // Update analytes when group changes
        function updateAnalytesForGroup() {
            const groupSelect = document.getElementById("groupSelect");
            const analyteSelect = document.getElementById("analyteSelect");
            analyteSelect.innerHTML = "";
            let selectedGroup = groups[groupSelect.value];
            selectedGroup.forEach(a => {
                if (rawData.find(d => d.analyte === a)) {
                    let option = document.createElement("option");
                    option.value = a;
                    option.text = a;
                    analyteSelect.add(option);
                }
            });
            updateChart();
        }
</script>
</body>
</html>
