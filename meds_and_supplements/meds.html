<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Medication & Supplementation Timeline</title>
    <script src="https://cdn.plot.ly/plotly-3.1.1.min.js" integrity="sha256-HUEFyfiTnZJxCxur99FjbKYTvKSzwDaD3/x5TqHpFu4=" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 10px;
        }

        #chart {
            height: 780px;
            width: 100%;
        }

        .error {
            color: #d32f2f;
            padding: 20px;
            background: #ffebee;
            border-radius: 4px;
            margin: 20px 0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Medication & Supplementation Timeline</h1>
        <div id="loading" class="loading">Loading data...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="chart"></div>
    </div>

    <script>
        // Global data storage
        let configData = null;

        // Function to determine bucket for a given function
        function bucketForFunction(func, rules) {
            for (const [bucket, fnList] of Object.entries(rules)) {
                if (fnList && fnList.includes(func)) {
                    return bucket;
                }
            }
            return "Gut/Other";
        }

        // Function to build dataframe-like structure from JSON
        function buildDataStructure(data) {
            const timeOrder = data.time_order || ["Morning", "Midday", "Evening", "Dinner", "Bedtime"];
            const settings = data.settings || {};
            const rules = settings.bucket_rules || {};
            const items = data.items || [];

            // Compute order within each time slot
            const orderMap = {};
            const rows = [];

            items.forEach(item => {
                const time = item.time;
                orderMap[time] = (orderMap[time] || 0) + 1;
                const func = item.function;
                const bucket = bucketForFunction(func, rules);

                rows.push({
                    time: time,
                    orderInSlot: orderMap[time],
                    compound: item.compound,
                    function: func,
                    dosage: item.dosage || "",
                    bucket: bucket
                });
            });

            return { rows, timeOrder, settings };
        }

        // Function to create visible mask for button filters
        function visibleMask(bucketOrder, showBucket) {
            return bucketOrder.map(b => b === showBucket || showBucket === "All");
        }

        // Function to create Plotly figure
        function makeFigure(rows, timeOrder, settings) {
            const bucketOrder = settings.bucket_order || ["Liver", "Sleep", "Anti-inflammatory", "Gut/Other"];
            const legendCfg = settings.legend || {};
            const figCfg = settings.figure || {};
            const labels = settings.labels || {};
            const tracesCfg = settings.traces || {};
            const buttonsBar = settings.buttons_bar || {};

            const markerSize = tracesCfg.marker_size || 12;
            const textfontSize = tracesCfg.textfont_size || 9;
            const textposition = tracesCfg.textposition || "top center";

            const traces = [];

            // Create a trace for each bucket
            bucketOrder.forEach(bucket => {
                const bucketData = rows.filter(row => row.bucket === bucket);
                
                const trace = {
                    x: bucketData.map(row => row.time),
                    y: bucketData.map(row => row.orderInSlot),
                    mode: "markers+text",
                    text: bucketData.map(row => row.compound),
                    textposition: textposition,
                    textfont: { size: textfontSize },
                    name: bucket,
                    hovertemplate: bucketData.map(row => 
                        `<b>${row.compound}</b><br>` +
                        `Bucket: ${bucket}<br>` +
                        `Function: ${row.function}<br>` +
                        `Dosage: ${row.dosage}<extra></extra>`
                    ),
                    customdata: bucketData.map(row => [row.function, row.dosage]),
                    marker: { size: markerSize },
                    type: "scatter"
                };

                traces.push(trace);
            });

            // Create filter buttons
            const buttons = [
                {
                    label: "All",
                    method: "update",
                    args: [{ visible: visibleMask(bucketOrder, "All") }]
                },
                {
                    label: "Liver only",
                    method: "update",
                    args: [{ visible: visibleMask(bucketOrder, "Liver") }]
                },
                {
                    label: "Sleep only",
                    method: "update",
                    args: [{ visible: visibleMask(bucketOrder, "Relaxation/Sleep") }]
                },
                {
                    label: "Anti-inflammatory only",
                    method: "update",
                    args: [{ visible: visibleMask(bucketOrder, "Anti-inflammatory") }]
                },
                {
                    label: "Gut/Other only",
                    method: "update",
                    args: [{ visible: visibleMask(bucketOrder, "Gut/Other") }]
                }
            ];

            // Build layout
            const layout = {
                title: {
                    text: labels.title || "Medication & Supplementation â€” Interactive Timeline"
                },
                xaxis: {
                    title: { text: labels.xaxis_title || "Time of Day" },
                    categoryorder: "array",
                    categoryarray: timeOrder
                },
                yaxis: {
                    title: { text: labels.yaxis_title || "Order within Time Slot" },
                    dtick: 1,
                    rangemode: "tozero"
                },
                legend: {
                    orientation: legendCfg.orientation || "v",
                    x: legendCfg.x !== undefined ? legendCfg.x : 1.02,
                    y: legendCfg.y !== undefined ? legendCfg.y : 1.0,
                    xanchor: legendCfg.xanchor || "left",
                    yanchor: legendCfg.yanchor || "top",
                    bgcolor: legendCfg.bgcolor || "rgba(255,255,255,0.9)",
                    bordercolor: legendCfg.bordercolor || "rgba(0,0,0,0.2)",
                    borderwidth: legendCfg.borderwidth !== undefined ? legendCfg.borderwidth : 1
                },
                margin: figCfg.margin || { l: 60, r: 200, t: 80, b: 60 },
                height: figCfg.height || 760,
                updatemenus: [
                    {
                        type: "buttons",
                        direction: "right",
                        buttons: buttons,
                        x: buttonsBar.x !== undefined ? buttonsBar.x : 0.5,
                        y: buttonsBar.y !== undefined ? buttonsBar.y : 1.12,
                        xanchor: buttonsBar.xanchor || "center",
                        yanchor: buttonsBar.yanchor || "top",
                        bgcolor: buttonsBar.bgcolor || "rgba(255,255,255,0.8)",
                        bordercolor: buttonsBar.bordercolor || "rgba(0,0,0,0.25)",
                        borderwidth: buttonsBar.borderwidth !== undefined ? buttonsBar.borderwidth : 1,
                        pad: buttonsBar.pad || { r: 5, t: 2, b: 2, l: 5 }
                    }
                ]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };

            return { traces, layout, config };
        }

        // Function to load JSON and render plot
        async function loadAndRender() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const chartEl = document.getElementById('chart');

            try {
                // Load JSON file from same directory
                const jsonUrl = new URL('med_schedule.json', window.location.href).href;
                const response = await fetch(jsonUrl);
                
                if (!response.ok) {
                    throw new Error(`Failed to load med_schedule.json: HTTP ${response.status}`);
                }

                configData = await response.json();
                
                // Build data structure
                const { rows, timeOrder, settings } = buildDataStructure(configData);
                
                // Create figure
                const { traces, layout, config } = makeFigure(rows, timeOrder, settings);
                
                // Render with Plotly
                Plotly.newPlot('chart', traces, layout, config);
                
                // Hide loading message
                loadingEl.style.display = 'none';
                
            } catch (error) {
                console.error('Error loading or rendering chart:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                errorEl.textContent = `Error: ${error.message}. Make sure med_schedule.json is in the same directory as this HTML file.`;
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', loadAndRender);
    </script>
</body>

</html>
