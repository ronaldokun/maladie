<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Blood Markers Evolution Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 10px;
        }

        .chart-container {
            margin: 30px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .dropdown-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            min-width: 250px;
        }

        .download-buttons {
            display: flex;
            gap: 10px;
        }

        .download-btn {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .download-btn:hover {
            background: #005999;
        }

        .altered {
            color: red;
            font-weight: bold;
        }

        .focus-box {
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, #fff3cd 0%, #f8d7da 100%);
            border: 2px solid #dc3545;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.2);
            display: none;
        }

        .focus-box.visible {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-box h3 {
            margin: 0 0 15px 0;
            color: #721c24;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .focus-box h3:before {
            content: "‚ö†Ô∏è";
            font-size: 20px;
        }

        .focus-box-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .focus-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
        }

        .focus-item-name {
            font-weight: bold;
            color: #721c24;
            margin-bottom: 5px;
        }

        .focus-item-value {
            font-size: 16px;
            color: #dc3545;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .direction-arrow {
            font-size: 18px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 24px;
            text-align: center;
        }

        .arrow-up {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            border: 1px solid rgba(220, 53, 69, 0.3);
        }

        .arrow-down {
            color: #fd7e14;
            background: rgba(253, 126, 20, 0.1);
            border: 1px solid rgba(253, 126, 20, 0.3);
        }

        .focus-item-reference {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .focus-box-empty {
            text-align: center;
            color: #28a745;
            font-weight: bold;
            background: rgba(40, 167, 69, 0.1);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #28a745;
        }

        .percentage-deviation {
            font-size: 14px;
            font-weight: bold;
            color: #6c757d;
            background: rgba(108, 117, 125, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
            border: 1px solid rgba(108, 117, 125, 0.2);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Blood Markers Evolution Analysis</h1>
        <p><strong>Patient:</strong> [ANONYMIZED] (ID: [REDACTED])</p>
        <p id="periodText"><strong>Period:</strong> Loading...</p>
        <div class="controls">
            <div class="dropdown-container">
                <label for="groupSelect"><strong>Select Group:</strong></label>
                <select id="groupSelect" onchange="updateAnalytesForGroup()"></select>
            </div>

            <div class="dropdown-container">
                <label for="analyteSelect"><strong>Select Analyte:</strong></label>
                <select id="analyteSelect" onchange="updateChart()">
                </select>
            </div>
            <div class="download-buttons">
                <button class="download-btn" onclick="downloadPivotCSV()">Download Pivot Table CSV</button>
                <button class="download-btn" onclick="downloadTidyCSV()">Download Tidy Data CSV</button>
            </div>
        </div>
        <div class="chart-container">
            <h2>Interactive Evolution Chart</h2>
            <div class="info-box"
                style="margin-bottom: 10px; padding: 8px; background-color: #f8f9fa; border-radius: 5px; font-size: 14px;">
                <p style="margin: 0;"><strong>Navigation tips:</strong> Use the range slider below to zoom and pan.
                    <strong>üìç Exam Reports:</strong> <span style="color: #ff8c00;">Orange</span> dotted lines and
                    triangle markers indicate when imaging studies were performed.
                    Click triangle markers to view report details.
                </p>
            </div>
            <div id="plotlyChart" style="height: 700px;"></div>
            <div id="fileLoader"
                style="display:none; margin-top: 12px; padding: 10px; background:#fff3cd; border:1px solid #ffeeba; border-radius:6px;">
                <p style="margin:0 0 8px 0;">Could not load blood_markers_pivot.csv automatically. If you opened this
                    file directly from your disk (file://), please choose the CSV located in the same folder as this
                    HTML:</p>
                <input type="file" id="csvInput" accept=".csv" />
            </div>
        </div>
        <div class="chart-container">
            <div id="focusBox" class="focus-box">
                <h3>Latest Results - Attention Required</h3>
                <div id="focusBoxContent" class="focus-box-content">
                    <!-- Content will be dynamically generated -->
                </div>
            </div>
        </div>

        <!-- Modal for focused report view -->
        <div id="reportModal"
            style="display:none; position:fixed; inset:5%; background:#fff; border-radius:8px; padding:16px; box-shadow:0 8px 32px rgba(0,0,0,0.3); overflow:auto; z-index: 1000;">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                <h3 id="reportTitle" style="margin:0;"></h3>
                <button onclick="document.getElementById('reportModal').style.display='none'">Close</button>
            </div>
            <div id="reportMeta" style="color:#666; margin-top:4px;"></div>
            <div id="reportLinks" style="margin:8px 0; display:flex; gap:12px; flex-wrap:wrap;"></div>
            <div id="reportBody" style="margin-top:12px;"></div>
        </div>
    </div>
    <script>
        // Global variables for data - will be populated from CSV
        let rawData = [];
        let dateTimes = [];
        let isDataLoaded = false;

        // Function to load and parse CSV data
        async function loadCSVData() {
            try {
                // Always expect CSV in the same folder as index.html
                const csvUrl = new URL('blood_markers_pivot.csv', window.location.href).href;
                const response = await fetch(csvUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const csvText = await response.text();
                parseCSVText(csvText);
                isDataLoaded = true;
                updatePeriodDisplay();
                console.log(`Loaded ${rawData.length} analytes with ${dateTimes.length} time points`);
            } catch (error) {
                console.warn('Automatic CSV load failed (likely due to file:// restrictions). Enabling manual file picker...', error);
                // Show file picker fallback for local file access
                enableManualCSVPicker();
                isDataLoaded = false;
            }
        }

        // Parse CSV text into rawData/dateTimes
        function parseCSVText(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('Invalid CSV format');
            }
            // Parse header row to get dates
            const headers = parseCSVLine(lines[0]);
            dateTimes = headers.slice(1, -1); // Remove first (ANALITOS) and last (VALORES DE REFERENCIA) columns
            // Parse data rows
            rawData = [];
            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (row.length < 3) continue; // Skip incomplete rows
                const analyteName = row[0];
                const values = row.slice(1, -1); // Remove first and last columns
                const referenceWithUnit = row[row.length - 1] || '';
                // Parse unit and reference from the last column
                const unitMatch = referenceWithUnit.match(/([^\s]+)$/);
                const unit = unitMatch ? unitMatch[1] : '';
                const reference = referenceWithUnit.replace(new RegExp('\\s*' + unit.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$'), '').trim();
                // Convert numeric values, keep strings as-is
                const processedValues = values.map(val => {
                    if (val === '----' || val === 'Inferior a 0.5' || val === 'Raras' || val === '---') {
                        return val;
                    }
                    const num = parseFloat(val);
                    return isNaN(num) ? val : num;
                });
                rawData.push({ analyte: analyteName, values: processedValues, unit: unit, reference: reference });
            }
        }

        // Show manual CSV picker and wire up parsing
        function enableManualCSVPicker() {
            const picker = document.getElementById('fileLoader');
            const input = document.getElementById('csvInput');
            if (!picker || !input) return;
            picker.style.display = 'block';
            input.addEventListener('change', function (ev) {
                const file = ev.target.files && ev.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        parseCSVText(e.target.result);
                        isDataLoaded = true;
                        picker.style.display = 'none';
                        populateGroups();
                        updateChart();
                        updatePeriodDisplay();
                    } catch (err) {
                        alert('Failed to parse CSV: ' + err.message);
                    }
                };
                reader.readAsText(file, 'utf-8');
            }, { once: true });
        }

        // Function to parse CSV line handling quoted values
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        // Function to update period display based on loaded data
        function updatePeriodDisplay() {
            if (!isDataLoaded || dateTimes.length === 0) return;

            // Find earliest and latest dates
            const dates = dateTimes.map(dateStr => {
                // Convert from DD/MM/YY or DD/MM/YYYY format to Date object
                const parts = dateStr.split(/[\s/]/);
                if (parts.length >= 3) {
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1; // Month is 0-indexed
                    let year = parseInt(parts[2]);

                    // Handle 2-digit years: assume 21st century (20xx) if year < 100
                    if (year < 100) {
                        year += 2000;
                    }

                    return new Date(year, month, day);
                }
                return new Date(dateStr);
            }).filter(date => !isNaN(date.getTime()));

            if (dates.length === 0) return;

            dates.sort((a, b) => a - b);
            const earliestDate = dates[0];
            const latestDate = dates[dates.length - 1];

            const diffTime = Math.abs(latestDate - earliestDate);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            const formatDate = (date) => {
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const year = date.getFullYear().toString().slice(-2); // Use last 2 digits
                return `${day}/${month}/${year}`;
            };

            // Update the period display in the DOM
            const periodElement = document.getElementById('periodText');
            if (periodElement) {
                periodElement.innerHTML = `<strong>Period:</strong> ${formatDate(earliestDate)} to ${formatDate(latestDate)} (${diffDays} days)`;
            }
        }

        // Function to parse reference ranges
        function parseReference(refString) {
            if (!refString || refString === "") return { min: null, max: null };

            const patterns = [
                /De\s+([\d.-]+)\s+at√©\s+([\d.]+)/i,
                /De\s+([\d.-]+)\s+a\s+([\d.]+)/i,
                /At√©\s+([\d.]+)/i,
                /at√©\s+([\d.]+)/i
            ];

            for (let pattern of patterns) {
                const match = refString.match(pattern);
                if (match) {
                    if (match[2]) {
                        return { min: parseFloat(match[1]), max: parseFloat(match[2]) };
                    } else {
                        return { min: null, max: parseFloat(match[1]) };
                    }
                }
            }

            return { min: null, max: null };
        }

        // Function to calculate median of valid numeric values
        function calculateMedian(values) {
            // Filter out invalid values and convert to numbers
            const numericValues = values.filter(val => {
                if (val === "----" || val === null || val === "Inferior a 0.5" || val === "Raras") return false;
                const num = parseFloat(val);
                return !isNaN(num);
            }).map(val => {
                if (val === "Inferior a 0.5") return 0.25;
                if (val === "Raras") return 0;
                return parseFloat(val);
            });

            if (numericValues.length === 0) return null;

            // Sort values
            numericValues.sort((a, b) => a - b);

            const mid = Math.floor(numericValues.length / 2);

            if (numericValues.length % 2 === 0) {
                return (numericValues[mid - 1] + numericValues[mid]) / 2;
            } else {
                return numericValues[mid];
            }
        }

        // Function to calculate mean of valid numeric values
        function calculateMean(values) {
            // Filter out invalid values and convert to numbers
            const numericValues = values.filter(val => {
                if (val === "----" || val === null || val === "Inferior a 0.5" || val === "Raras") return false;
                const num = parseFloat(val);
                return !isNaN(num);
            }).map(val => {
                if (val === "Inferior a 0.5") return 0.25;
                if (val === "Raras") return 0;
                return parseFloat(val);
            });

            if (numericValues.length === 0) return null;

            // Calculate mean
            const sum = numericValues.reduce((acc, val) => acc + val, 0);
            return sum / numericValues.length;
        }

        // Function to check if value is within reference range
        function isWithinRange(value, reference) {
            if (value === "----" || value === null || value === "Inferior a 0.5" || value === "Raras") return null;
            const ref = parseReference(reference);
            if (ref.min === null && ref.max === null) return null;

            const numValue = parseFloat(value);
            if (isNaN(numValue)) return null;

            if (ref.min !== null && ref.max !== null) {
                return numValue >= ref.min && numValue <= ref.max;
            } else if (ref.max !== null) {
                return numValue <= ref.max;
            }
            return null;
        }

        // Function to determine direction of out-of-range value
        function getOutOfRangeDirection(value, reference) {
            const ref = parseReference(reference);
            const numValue = parseFloat(value);

            if (isNaN(numValue) || (ref.min === null && ref.max === null)) {
                return null;
            }

            if (ref.min !== null && ref.max !== null) {
                // Both min and max defined
                if (numValue < ref.min) return 'down';
                if (numValue > ref.max) return 'up';
                return null;
            } else if (ref.max !== null) {
                // Only max defined
                if (numValue > ref.max) return 'up';
                return null;
            }

            return null;
        }

        // Function to calculate percentage deviation from reference range
        function calculatePercentageDeviation(value, reference) {
            const ref = parseReference(reference);
            const numValue = parseFloat(value);

            if (isNaN(numValue) || (ref.min === null && ref.max === null)) {
                return null;
            }

            if (ref.min !== null && ref.max !== null) {
                // Both min and max defined
                if (numValue < ref.min) {
                    // Below minimum: calculate percentage below min
                    const deviation = ((ref.min - numValue) / ref.min) * 100;
                    return `-${deviation.toFixed(1)}%`;
                } else if (numValue > ref.max) {
                    // Above maximum: calculate percentage above max
                    const deviation = ((numValue - ref.max) / ref.max) * 100;
                    return `+${deviation.toFixed(1)}%`;
                }
                return null;
            } else if (ref.max !== null) {
                // Only max defined
                if (numValue > ref.max) {
                    const deviation = ((numValue - ref.max) / ref.max) * 100;
                    return `+${deviation.toFixed(1)}%`;
                }
                return null;
            }

            return null;
        }

        // Function to get out-of-range values for the latest non-null data point of each analyte
        function getLatestOutOfRangeValues() {
            const outOfRange = [];

            rawData.forEach(analyte => {
                // Find the latest non-null value for this analyte
                let latestValue = null;
                let latestValueDate = null;

                for (let i = 0; i < analyte.values.length; i++) {
                    const value = analyte.values[i];
                    if (value !== "----" && value !== null && value !== "" && value !== undefined) {
                        latestValue = value;
                        latestValueDate = dateTimes[i];
                        break; // Since values are ordered from most recent to oldest
                    }
                }

                // If we found a valid latest value, check if it's out of range
                if (latestValue !== null) {
                    const withinRange = isWithinRange(latestValue, analyte.reference);

                    if (withinRange === false && analyte.reference && analyte.reference.trim() !== "") {
                        // Handle special values for display
                        let displayValue = latestValue;
                        if (latestValue === "Inferior a 0.5") displayValue = "<0.5";

                        // Determine direction
                        const direction = getOutOfRangeDirection(latestValue, analyte.reference);

                        // Calculate percentage deviation
                        const percentageDeviation = calculatePercentageDeviation(latestValue, analyte.reference);

                        outOfRange.push({
                            name: analyte.analyte,
                            value: displayValue,
                            unit: analyte.unit,
                            reference: analyte.reference,
                            rawValue: latestValue,
                            direction: direction,
                            date: latestValueDate,
                            percentage: percentageDeviation
                        });
                    }
                }
            });

            return outOfRange;
        }

        // Function to update the focus box
        function updateFocusBox() {
            const outOfRange = getLatestOutOfRangeValues();
            const focusBox = document.getElementById('focusBox');
            const focusBoxContent = document.getElementById('focusBoxContent');

            if (outOfRange.length === 0) {
                focusBoxContent.innerHTML = '<div class="focus-box-empty">‚úÖ All latest measurements are within reference ranges</div>';
                focusBox.className = 'focus-box visible';
                focusBox.style.background = 'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)';
                focusBox.style.borderColor = '#28a745';
            } else {
                let contentHtml = '';
                outOfRange.forEach(item => {
                    // Create arrow indicator based on direction
                    let arrowHtml = '';
                    let percentageHtml = '';

                    if (item.direction === 'up') {
                        arrowHtml = '<span class="direction-arrow arrow-up">‚Üë</span>';
                    } else if (item.direction === 'down') {
                        arrowHtml = '<span class="direction-arrow arrow-down">‚Üì</span>';
                    }

                    // Add percentage if available
                    if (item.percentage) {
                        percentageHtml = ` <span class="percentage-deviation">(${item.percentage})</span>`;
                    }

                    contentHtml += `
                        <div class="focus-item">
                            <div class="focus-item-name">${item.name}</div>
                            <div class="focus-item-value">${arrowHtml}${item.value} ${item.unit}${percentageHtml}</div>
                            <div class="focus-item-reference">Reference: ${item.reference} ${item.unit}</div>
                            <div class="focus-item-reference">Date: ${item.date || 'N/A'}</div>
                        </div>
                    `;
                });
                focusBoxContent.innerHTML = contentHtml;
                focusBox.className = 'focus-box visible';
                focusBox.style.background = 'linear-gradient(135deg, #fff3cd 0%, #f8d7da 100%)';
                focusBox.style.borderColor = '#dc3545';

                // Update the title to show count
                const titleElement = focusBox.querySelector('h3');
                titleElement.textContent = `Latest Results - ${outOfRange.length} Measurement${outOfRange.length > 1 ? 's' : ''} Outside Reference Range`;
            }
        }

        // Create dropdown options
        function createDropdown() {
            const select = document.getElementById('analyteSelect');
            rawData.forEach(row => {
                const option = document.createElement('option');
                option.value = row.analyte;
                option.textContent = row.analyte;
                select.appendChild(option);
            });
            // Select first analyte by default
            if (rawData.length > 0) {
                select.value = rawData[0].analyte;
            }
        }

        // Create plotly chart for selected analyte
        function updateChart() {
            const selectedAnalyte = document.getElementById('analyteSelect').value;
            const analyte = rawData.find(a => a.analyte === selectedAnalyte);
            if (!analyte) return;

            // Reverse the order for chronological display (left to right)
            const reversedDates = [...dateTimes].reverse();
            const reversedValues = [...analyte.values].reverse();

            // Filter out invalid values and get corresponding dates
            const validData = reversedValues.map((value, idx) => ({
                value: value,
                date: reversedDates[idx],
                originalValue: value
            })).filter(item => item.value !== "----");

            if (validData.length === 0) return;

            const validDates = validData.map(item => item.date);
            const validValues = validData.map(item => {
                // Handle special values
                if (item.value === "Inferior a 0.5") return 0.25;
                if (item.value === "Raras") return 0;
                return parseFloat(item.value);
            });

            // Create trace
            const trace = {
                x: validDates,
                y: validValues,
                name: analyte.analyte,
                mode: 'lines+markers+text',
                connectgaps: true,
                text: validData.map(item => {
                    if (item.originalValue === "Inferior a 0.5") return "<0.5";
                    if (item.originalValue === "Raras") return "Raras";
                    return `${item.originalValue}`;
                }),
                textposition: 'top center',
                textfont: { size: 12 },
                hovertemplate: `<b>${analyte.analyte}</b><br>` +
                    `DateTime: %{x}<br>` +
                    `Value: %{text} ${analyte.unit}<br>` +
                    `Reference: ${analyte.reference} ${analyte.unit}<br>` +
                    `<extra></extra>`,
                line: { width: 3, color: '#007acc' },
                marker: { size: 8, color: '#007acc' },
                textangle: 0
            };

            // Calculate median and mean for trend analysis
            const medianValue = calculateMedian(analyte.values);
            const meanValue = calculateMean(analyte.values);

            const traces = [trace];
            const shapes = [];

            // Add median line if available
            if (medianValue !== null) {
                shapes.push({
                    type: 'line',
                    x0: 0,
                    x1: 1,
                    xref: 'paper',
                    y0: medianValue,
                    y1: medianValue,
                    line: {
                        color: 'rgba(255, 165, 0, 0.8)', // Orange color
                        width: 2,
                        dash: 'dot'
                    },
                    layer: 'above'
                });
            }

            // Add mean line if available
            if (meanValue !== null) {
                shapes.push({
                    type: 'line',
                    x0: 0,
                    x1: 1,
                    xref: 'paper',
                    y0: meanValue,
                    y1: meanValue,
                    line: {
                        color: 'rgba(138, 43, 226, 0.8)', // Purple color
                        width: 2,
                        dash: 'dot'
                    },
                    layer: 'above'
                });
            }

            // Calculate historical min and max values
            const numericValues = validValues.filter(val => !isNaN(val) && val !== null);
            let historicalMin = null;
            let historicalMax = null;

            if (numericValues.length > 0) {
                historicalMin = Math.min(...numericValues);
                historicalMax = Math.max(...numericValues);

                // Add historical minimum line
                shapes.push({
                    type: 'line',
                    x0: 0,
                    x1: 1,
                    xref: 'paper',
                    y0: historicalMin,
                    y1: historicalMin,
                    line: {
                        color: 'rgba(255, 99, 132, 0.7)', // Red color for minimum
                        width: 2,
                        dash: 'dashdot'
                    },
                    layer: 'above'
                });

                // Add historical maximum line
                shapes.push({
                    type: 'line',
                    x0: 0,
                    x1: 1,
                    xref: 'paper',
                    y0: historicalMax,
                    y1: historicalMax,
                    line: {
                        color: 'rgba(54, 162, 235, 0.7)', // Blue color for maximum
                        width: 2,
                        dash: 'dashdot'
                    },
                    layer: 'above'
                });

                // Add legend traces in order: Historical Min, Median, Historical Max
                traces.push({
                    x: [null],
                    y: [null],
                    mode: 'lines',
                    name: `Historical Min (${historicalMin.toFixed(2)} ${analyte.unit})`,
                    line: {
                        color: 'rgba(255, 99, 132, 0.7)',
                        width: 2,
                        dash: 'dashdot'
                    },
                    showlegend: true
                });

                // Add median trace for legend (if available)
                if (medianValue !== null) {
                    traces.push({
                        x: [null],
                        y: [null],
                        mode: 'lines',
                        name: `Median Trend (${medianValue.toFixed(2)} ${analyte.unit})`,
                        line: {
                            color: 'rgba(255, 165, 0, 0.8)',
                            width: 2,
                            dash: 'dot'
                        },
                        showlegend: true
                    });
                }

                // Add mean trace for legend (if available)
                if (meanValue !== null) {
                    traces.push({
                        x: [null],
                        y: [null],
                        mode: 'lines',
                        name: `Mean Trend (${meanValue.toFixed(2)} ${analyte.unit})`,
                        line: {
                            color: 'rgba(138, 43, 226, 0.8)',
                            width: 2,
                            dash: 'dot'
                        },
                        showlegend: true
                    });
                }

                traces.push({
                    x: [null],
                    y: [null],
                    mode: 'lines',
                    name: `Historical Max (${historicalMax.toFixed(2)} ${analyte.unit})`,
                    line: {
                        color: 'rgba(54, 162, 235, 0.7)',
                        width: 2,
                        dash: 'dashdot'
                    },
                    showlegend: true
                });
            }

            // Add reference range as filled area if available
            const ref = parseReference(analyte.reference);
            if (ref.min !== null || ref.max !== null) {
                // Create filled reference range area
                if (ref.min !== null && ref.max !== null) {
                    // Both min and max defined - create filled rectangle
                    shapes.push({
                        type: 'rect',
                        x0: 0,
                        x1: 1,
                        xref: 'paper',
                        y0: ref.min,
                        y1: ref.max,
                        fillcolor: 'rgba(144, 238, 144, 0.3)', // Light green with transparency
                        line: {
                            width: 0
                        },
                        layer: 'below'
                    });
                } else if (ref.max !== null) {
                    // Only max defined - create filled area from bottom to max
                    const yAxisMin = Math.min(...validValues) * 0.8; // Estimate bottom of plot
                    shapes.push({
                        type: 'rect',
                        x0: 0,
                        x1: 1,
                        xref: 'paper',
                        y0: yAxisMin,
                        y1: ref.max,
                        fillcolor: 'rgba(144, 238, 144, 0.3)', // Light green with transparency
                        line: {
                            width: 0
                        },
                        layer: 'below'
                    });
                }

                // Add invisible trace for reference range legend
                traces.push({
                    x: [null],
                    y: [null],
                    mode: 'markers',
                    marker: {
                        size: 10,
                        color: 'rgba(144, 238, 144, 0.8)',
                        symbol: 'square'
                    },
                    name: 'Reference Range',
                    showlegend: true
                });
            }

            // Add report markers aligned with visible dates for this analyte
            if (Array.isArray(reports) && reports.length) {
                const reportData = getReportMarkersAndTraces(validDates, validValues);
                if (reportData.shapes.length) {
                    shapes.push(...reportData.shapes);
                }
                if (reportData.trace) {
                    traces.push(reportData.trace);
                }
            }

            const layout = {
                title: {
                    text: `${analyte.analyte} Evolution Over Time`,
                    font: { size: 18 }
                },
                xaxis: {
                    title: 'Date/Time',
                    tickangle: -45,
                    type: 'category',
                    rangeslider: { visible: true },
                    automargin: true,
                    rangemode: 'normal',
                    // Set range to only include dates with valid data for this analyte
                    range: validDates.length > 1 ? [validDates[0], validDates[validDates.length - 1]] : undefined,
                    // Show only the relevant date categories
                    categoryorder: 'array',
                    categoryarray: validDates
                },
                yaxis: {
                    title: `Value (${analyte.unit})`,
                    automargin: true
                },
                hovermode: 'closest',
                showlegend: true,
                shapes: shapes,
                margin: { r: 50, b: 120, t: 80, l: 80 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                scrollZoom: true,
                modeBarButtonsToAdd: ['scrollZoom', 'pan2d', 'zoomIn2d', 'zoomOut2d', 'resetScale2d'],
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };

            Plotly.newPlot('plotlyChart', traces, layout, config);

            // Add click event handler for report markers
            const chartEl = document.getElementById('plotlyChart');
            if (chartEl && typeof chartEl.on === 'function') {
                chartEl.on('plotly_click', (data) => {
                    const point = data?.points?.[0];
                    if (point && point.customdata) {
                        // This is a report marker click
                        openReport(point.customdata);
                    }
                });
            }

            // Update the focus box with latest out-of-range values
            updateFocusBox();
        }

        // Download functions
        function downloadPivotCSV() {
            let csv = 'ANALITOS,';
            csv += dateTimes.join(',') + ',VALORES DE REFERENCIA\n';

            rawData.forEach(row => {
                csv += row.analyte + ',';
                csv += row.values.join(',') + ',';
                csv += '"' + row.reference + ' ' + row.unit + '"\n';
            });

            downloadCSV(csv, 'blood_markers_pivot.csv');
        }

        function downloadTidyCSV() {
            let csv = 'Analyte,DateTime,Value,Unit,Reference Range,Within Range\n';

            rawData.forEach(row => {
                row.values.forEach((value, index) => {
                    if (value !== "----") {
                        const withinRange = isWithinRange(value, row.reference);
                        const withinRangeText = withinRange === null ? 'N/A' : (withinRange ? 'Yes' : 'No');
                        csv += `"${row.analyte}","${dateTimes[index]}","${value}","${row.unit}","${row.reference}","${withinRangeText}"\n`;
                    }
                });
            });

            downloadCSV(csv, 'blood_markers_tidy.csv');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', async function () {
            // Show loading message
            const chartContainer = document.getElementById('plotlyChart');
            chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 400px; font-size: 18px; color: #666;">Loading data...</div>';

            // Load CSV data first
            await loadCSVData();

            if (isDataLoaded) {
                populateGroups();
                updateChart();
            } else {
                chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 400px; font-size: 18px; color: #d32f2f;">Error: Could not load data from CSV file</div>';
            }
        });

        const groups = {
            "Inflammatory": ["Prote√≠na C reativa", "Prote√≠na C reativa Ultrassens√≠vel", "Calprotectina"],
            "Hematology": ["Hemoglobina", "Hem√°cias", "Hemat√≥crito", "RDW", "RDW-SD", "Leuc√≥citos", "Plaquetas", "Linf√≥citos", "Neutr√≥filos", "Mon√≥citos", "Eosin√≥filos", "Bas√≥filos", "Bast√µes", "VCM", "HCM", "CHCM", "VPM"],
            "Kidney": ["Creatinina", "Ureia"],
            "Liver": ["TGO", "TGP", "Gama GT", "Fosfatase alcalina", "Bilirrubina Total", "Bilirrubina Direta", "Bilirrubina Indireta"],
            "Electrolytes / Minerals": ["S√≥dio", "Pot√°ssio", "Calcio I√¥nico", "Magnesio", "C√°lcio Total", "F√≥sforo", "Ferro"],
            "Coagulation": ["RNI", "TAP", "TTPA", "Rela√ß√£o"],
            "Lipids": ["Colesterol", "HDL - Colesterol", "N√£o - HDL - Colesterol", "VLDL - Colesterol", "LDL - Colesterol", "Triglic√©rides"],
            "Metabolism": ["Glicose", "Hemoglobina Glicada"],
            "Enzymes": ["Creatino fosfoquinase", "Amilase", "Lipase"],
            "Proteins": ["Prote√≠nas Totais", "Albumina", "Globulinas", "Transferrina", "Ferritina"],
            "Hormones": ["Hormonio Foliculo-Estimulante (FSH)", "Hormonio Luteinizante (LH)", "Triiodotironina (T3)", "Tiroxina (T4)", "Testosterona Livre", "Globulina Ligadora dos Hormonios Sexuais (SHBG)", "Testosterona Total", "Hormonio Tireo-Estimulante (TSH)", "Cortisol"],
            "Vitamins": ["√Åcido F√≥lico", "Vitamina B 12", "25-Hidroxivitamina D"],
            "Tumor Markers": ["CA19.9"]
        };

        // Populate group dropdown
        function populateGroups() {
            const groupSelect = document.getElementById("groupSelect");
            Object.keys(groups).forEach(g => {
                let option = document.createElement("option");
                option.value = g;
                option.text = g;
                groupSelect.add(option);
            });
            updateAnalytesForGroup();
        }

        // Update analytes when group changes
        function updateAnalytesForGroup() {
            const groupSelect = document.getElementById("groupSelect");
            const analyteSelect = document.getElementById("analyteSelect");
            analyteSelect.innerHTML = "";
            let selectedGroup = groups[groupSelect.value];
            selectedGroup.forEach(a => {
                if (rawData.find(d => d.analyte === a)) {
                    let option = document.createElement("option");
                    option.value = a;
                    option.text = a;
                    analyteSelect.add(option);
                }
            });
            updateChart();
        }
        // ---------------- Reports Timeline & Modal ----------------
        let reports = [];

        async function loadReports() {
            try {
                const url = new URL('reports.json', window.location.href).href;
                const res = await fetch(url);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                reports = Array.isArray(data) ? data : [];
            } catch (e) {
                console.warn('Could not load reports.json automatically.', e);
                reports = [];
            }
        }


        async function openReport(id) {
            const r = reports.find(x => x.id === id);
            if (!r) return;
            document.getElementById('reportTitle').textContent = `${r.modality} ‚Äî ${r.title}`;
            const metaParts = [r.datetime];
            if (Array.isArray(r.tags) && r.tags.length) metaParts.push(r.tags.join(', '));
            document.getElementById('reportMeta').textContent = metaParts.filter(Boolean).join(' ‚Ä¢ ');
            const bodyEl = document.getElementById('reportBody');
            let md = r.body_md || '';
            
            // If body_md_file is specified, fetch the markdown from file
            if (r.body_md_file && !md) {
                try {
                    const mdUrl = new URL(r.body_md_file, window.location.href).href;
                    const res = await fetch(mdUrl);
                    if (res.ok) {
                        md = await res.text();
                    } else {
                        md = r.summary || `Could not load report content from ${r.body_md_file}`;
                    }
                } catch (e) {
                    console.warn('Error loading markdown file:', e);
                    md = r.summary || 'Error loading report content';
                }
            } else {
                md = md || r.summary || '';
            }
            
            bodyEl.innerHTML = (window.marked ? marked.parse(md) : md);
            const linksEl = document.getElementById('reportLinks');
            const links = (r.attachments || []).map(a => `<a href="${a.href}" target="_blank" rel="noopener">${(a.type || 'file').toUpperCase()}</a>`);
            linksEl.innerHTML = links.join(' ¬∑ ');
            document.getElementById('reportModal').style.display = 'block';
            try { history.replaceState(null, '', `#report=${encodeURIComponent(id)}`); } catch (e) { }
        }

        function maybeOpenReportFromHash() {
            const m = location.hash.match(/#report=([^&]+)/);
            if (m) openReport(decodeURIComponent(m[1]));
        }

        // Normalize a Date to CSV header category format: DD/MM/YY HH:MM
        function formatToCsvCategory(date) {
            const pad = (n) => String(n).padStart(2, '0');
            const dd = pad(date.getDate());
            const mm = pad(date.getMonth() + 1);
            const yy = String(date.getFullYear()).slice(-2);
            const HH = pad(date.getHours());
            const MM = pad(date.getMinutes());
            return `${dd}/${mm}/${yy} ${HH}:${MM}`;
        }

        // Helper function to parse date strings in DD/MM/YY HH:MM format
        function parseDateString(dateStr) {
            const parts = dateStr.split(/[\s\/:]/);
            if (parts.length >= 5) {
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                let year = parseInt(parts[2]);
                if (year < 100) year += 2000;
                const hour = parseInt(parts[3]);
                const minute = parseInt(parts[4]);
                return new Date(year, month, day, hour, minute);
            }
            return new Date(dateStr);
        }

        // Helper function to parse date strings to Date objects for comparison
        function parseReportDate(dateStr) {
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1; // Month is 0-indexed
                let year = parseInt(parts[2]);
                if (year < 100) year += 2000; // Handle 2-digit years
                return new Date(year, month, day);
            }
            return new Date(dateStr);
        }

        // Helper function to find the closest date position for non-matching reports
        function findClosestDatePosition(reportDate, validDates) {
            const reportDateObj = parseReportDate(reportDate);
            const validDateObjs = validDates.map(d => parseReportDate(d));

            let closestDate = null;
            let minDistance = Infinity;
            let closestIndex = -1;

            // Find the single closest date
            validDateObjs.forEach((dateObj, idx) => {
                const distance = Math.abs(reportDateObj - dateObj);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestDate = validDates[idx];
                    closestIndex = idx;
                }
            });

            if (closestDate !== null) {
                return {
                    position: closestIndex,
                    displayDate: closestDate, // Use the closest date as if it's exact
                    xPosition: closestIndex
                };
            }

            return null;
        }

        // Produce enhanced report markers with better visibility and interactivity
        function getReportMarkersAndTraces(validDates, validValues) {
            const result = { shapes: [], trace: null };
            if (!Array.isArray(validDates) || !validDates.length || !reports || reports.length === 0) return result;

            const validSet = new Set(validDates);
            const allReports = [];
            const reportPositions = [];
            const reportLabels = [];
            const reportIds = [];
            const finalDates = []; // The actual dates we'll use for positioning

            // Process all reports (both matching and non-matching dates)
            reports.forEach(r => {
                let position, finalDate;

                if (validSet.has(r.datetime)) {
                    // Exact match - use the actual date position
                    const dateIndex = validDates.indexOf(r.datetime);
                    position = dateIndex;
                    finalDate = r.datetime;
                } else {
                    // No exact match - find closest position
                    const closestInfo = findClosestDatePosition(r.datetime, validDates);
                    if (closestInfo) {
                        position = closestInfo.position;
                        finalDate = closestInfo.displayDate; // Use the closest date
                    } else {
                        return; // Skip if we can't find a good position
                    }
                }

                allReports.push(r);
                reportPositions.push(position);
                reportLabels.push(`${r.modality}: ${r.title}`);
                reportIds.push(r.id);
                finalDates.push(finalDate);

                // Create enhanced vertical line - always use orange and x coordinates
                result.shapes.push({
                    type: 'line',
                    xref: 'x',
                    yref: 'paper',
                    x0: finalDate,
                    x1: finalDate,
                    y0: 0,
                    y1: 1,
                    line: {
                        color: 'rgba(255, 140, 0, 0.6)', // Orange for all
                        width: 3,
                        dash: 'dot'
                    },
                    layer: 'below'
                });

                // Add a report indicator at the top - always orange
                result.shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: finalDate,
                    x1: finalDate,
                    y0: 0.95,
                    y1: 1,
                    fillcolor: 'rgba(255, 140, 0, 0.15)',
                    line: {
                        color: 'rgba(255, 140, 0, 0.8)',
                        width: 1
                    },
                    layer: 'above'
                });
            });

            // Create an interactive trace for all report markers
            if (allReports.length > 0) {
                const maxY = Math.max(...validValues.filter(v => !isNaN(v)));

                result.trace = {
                    x: finalDates, // Use the final dates (either exact or closest)
                    y: finalDates.map(() => maxY * 1.05), // Same height for all
                    customdata: reportIds,
                    mode: 'markers+text',
                    name: `Exam Reports (${allReports.length})`,
                    marker: {
                        size: 16,
                        color: 'rgba(255, 140, 0, 0.8)', // Orange for all
                        symbol: 'triangle-up',
                        line: {
                            color: 'rgba(255, 255, 255, 1)',
                            width: 2
                        }
                    },
                    text: allReports.map(r => r.modality.charAt(0)),
                    textfont: {
                        size: 10,
                        color: 'white',
                        family: 'Arial Black'
                    },
                    textposition: 'middle center',
                    hovertext: allReports.map(r => {
                        return `<b>${r.modality}</b><br>${r.title}<br>Date: ${r.datetime}<br><i>Click to view details</i>`;
                    }),
                    hoverinfo: 'text',
                    showlegend: true
                };
            }

            return result;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await loadReports();
            // If labs are already loaded, refresh the chart so markers appear
            try { if (typeof isDataLoaded !== 'undefined' && isDataLoaded) updateChart(); } catch (_) { }
            maybeOpenReportFromHash();
        });
    </script>
</body>

</html>